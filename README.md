# Решение тестовых заданий на соискание должности perl разработчика
## Первое задание
### Удалить дубли из хеша
Дан хеш %h. Необходимо удалить из него лишние пары, у которых
значения повторяются (т.е. только 1 такую пару оставить) наиболее
эффективным методом. В хеше может быть миллион пар, так что
приоритет – процессорное время.
#### Решение
Я прежде ни когда не задумывался, а как быстро работает мой код. Не было повода. 
Некоторое время подумав, я сделал несколько реализаций, которые мне показались 
возможными/разумными, в данном случае.

Для запуска решения первой задачи используем скрипт task1.pl.

Подопытные функции:
* compact_for_loop - с циклом for перебираем хэш и выносим в результат только "новые" значения, текущее значение регистрируем во вспомогательном хэше увеличением соответствующего ему счетчика
* compact_each_loop - то же самое, что и for циклом, оказалось - есть разница
* compact_grep - grep может вычислять кодовый блок, попробуем воспользоваться этим, чтобы избавится от цикла
* compact_map - такая же попытка, но с помощью функции map
* compact_reverse_twice - если 2 раза позвать функцию reverse, то хэш избавится от дублирующих значений, но предсказать, какие ключи останутся - бывает сложно, есть подозрение, что последние
* compact_reverse_inplace - опять зовем reverse, только не создает промежуточный хэш, главное, что следует учитывать - портит исходный хэш
* compact_reverse_twice_pre - пытаемся ускорить compact_reverse_twice преалокацией памяти для промежуточных вычислений

Текстовый файл out.txt содержит протокол запуска task1.pl до добавления предварительного резервирования памяти в функуиях:
```perl
...
keys(%tmp) = scalar(keys %$src);
keys(%result) = scalar(keys %$src);
...
```
В файле out_op.txt результаты прогона после этой доработки.
## Второе задание
### Аксессоры
Напишите на Perl примитивный базовый класс MyApp::Accessor для
использования в качестве базового класса для генерации аксессоров
(методов которые сохраняют и отдают свойство объекта). Аксессоры
должны работать настолько быстро, насколько это возможно в принципе.
Какими технологиями/модулями, по вашему, лучше всего пользоваться в
реальной разработке для создания аксессоров?

P.S. Accessor – это примитивная функция, которая служит для доступа к
свойству объекта извне. Т.е. $obj->property – возвращает значение, а $obj->property($value) –
устанавливает.
#### Решение
Итак, требования, которым класс должен удовлетворять:
* быть быстрым при использовании - что означает генерацию всех необходимых методов при загрузке
* поддерживать переопредиление на текущем уровне, когда мы готовы 
использовать стандарный getter, а для setter, например, намерины добавить 
дополнительную логику
* поддерживать наследование

Модуль Accessor.pm реализует требуемый базовый класс. 
Сам я застрял где - то в районе игр с функцией AUTOLOAD, но в данном случае это не подходящее решение. 
Во первых, пожалуй устарело. Во вторых - сложности с наследованием. 
Поиск выдал Class::XSAccessor как подходящий под заданные критерии, он в итоге и был использован.

Модуль User.pm реализует промежуточную ступень наследования, а Task2.pm собирает все вместе и дает прикладной класс.
Скрипт task2.pl содержит небольшой тестовый пример, чтобы можно было убедиться в работоспособности всего решения.
## Третье задание
### Типы объявления переменных
Чем отличаются между собой переменные, объявленные с помощью my,
our, local, state?
#### Решение
Прежде всего, небольшое уточнение: перл динамический язык - тип переменной 
вытекает из текущего ее значения. Конечно же имеется ввиду область видимости 
переменной объявленной с каждым из перечисленных служебных слов.
* __my__ - блочная {} область видимости. По выходе из блока освобождается
* __our__ - пакетная область видимости. Видима все время существования пакета, 
если только не перекрыта объявлением с _my_.
* __local__ - позволяет временно перекрыть глобальное объявление.
* __state__ - блочная, как у _my_ область видимости, но позволяет сохранять 
значение между вызовами.
```perl
func() for 1..10;
sub func {
    XXX $var;
    $var++;
    say "A=$var";
}
```
Что и почему выведется, если в качестве _XXX_ подставлять
вышеуказанные 4 типа объявления переменных?

Для __my__ случая $var всегда будет равна 1. Это происходит потому что 
переменная каждый раз будет создаваться заново.

Для __our__ случая $var будет существовать в контексте пакета и, 
при повторных вызовах, не переопределится. Будут выведены числа от 1 до 10.

Для __local__ случая код не запустится, потому что не существует глобальной 
пременной $var.

Для __state__ случая выведутся числа от 1 до 10 потому что состояние будет 
созранятся меду вызовами.

```perl
sub func {
    my $var if 0;
    $var++;
    say “A=$var”;
}
```
Этот код, начиная с версии 5.30, в которой, если верить google, этот баг починили, 
не работает.
## Четвертое задание
### Обработка данных из БД
В базе данных есть большая таблица из 2х полей (id, data), на порядки
превышающая объем оперативной памяти. Нам требуется обработать её
(т.е. прочитать все значения data). 

Как бы вы это организовали? Какие проблемы могут возникнуть 
при такой обработке?

PS: Курсоры данная база не поддерживает.
#### Решение
Если данных очень много, и вычитывать последовательно невозможно / нежелательно, 
то придется читать по частям. 

Использовать offset для "листания" данных нельзя, потому как вставка / удаление 
между получением страниц приведет к пропускам или задвоениям записей и неверному 
результату в итоге. Соответственно, листать будем по диапазонам значений id.

Логика "листания" примерно такая:
```sql
-- Первый запрос
SELECT id, data FROM big_table ORDER BY id LIMIT 10000;
-- Следующий (запоминаем последний id из предыдущей выборки)
SELECT id, data FROM big_table WHERE id > :last_id ORDER BY id LIMIT 10000;
```
При таком подходе пограничные записи всегда существуют и мы их знаем.

Если id "неудобен" для фильтрации, например, является uuid значением, можем 
выгрузить значения id в локальную базу, например sqlite, или даже в csv, 
поделить там на группы (есть популярное слово - шарды, шардируем базу), 
и раздадим процессам и/или серверам эту нарезку для обработки по частям.

Раз мы работаем по кусочкам данных, то, становится критичным:
* фиксировать факт начала работы по "отдельному куску".
* фиксировать промежуточные результаты, особенно, если это поможет не делать
двойную работу в случае сбоя.
* фиксировать конечный результат обработки порции данных.
* устанавливать таймауты на все операции, где это возможно. Нет нужды ждать, 
пока система "сообразит", что работа пошла не по плану. Случится может все 
что угодно, база перегрузилась, процесс упал, сеть перестала нормально 
работать, чем быстрее мы об этом узнаем - тем быстрее все исправим.
* ловить и логгировать ошибки. То, что вы не позволили процессу упасть - 
совершенно не значит, что ваша миссия исчерпана. Ошибки надо исправлять, там 
где это возможно.
* ресурсами надо управлять. Ненужную память - освобождать, 
сокеты и дескрипторы закрывать, не надеясь на сборку мусора, 
временные файлы удалять, логи ротировать.

Конкретная оптимизация воркеров, которые работают по отдельному набору id, 
зависит от конкретной задачи. Если нужно просто посчитать, может оказаться 
разумным читать из "боевой" базы. Если обработка сложнее, а порции больше, 
чем 100 или даже 1000 записей, может оказаться разумным - создать временную 
таблицу, или даже таблицы, преобразовать их для упрощения получения 
результата, все посчитать, а когда нажда в них отпадет - аккуратно прибраться.
## Пятое задание
### Поправить утечку памяти
В данном примере память естественно утекает из-за перекрестных ссылок.
```perl
while (1) {
    my $a = {b => {}};
    $a->{b}{a} = $a;
}
```
1. Как правильно инициализировать перекрестные ссылки, чтобы память из-за них не утекала? 
2. Можно ли тут применить мягкие ссылки? 
3. Какие особенности работы с мягкими ссылками?
#### Решение
Исправленная версия выглядит так:
```perl
while (1) {
    my $a = {b => {}};
    $a->{b}{a} = $a;
    weaken($a->{b}{a});
}
```
Прежде чем отвечать на вопросы, вспомним, какие ссылки доставляют нам проблемы, 
потому как мами по себе ссылки - проблемой не являются. 

У нас, например, есть 
объекты A, B, C и D, которые ссылаются друг на друга таким образом: 
A->B->C->D->A. Подобные ссылки, обычно, называют циклическими. При попытке 
собрать такую конструкцию, коллектор не может получить ноль в счетчике ссылок 
и память не освобождается. Чтобы справится с проблемой, мы можем объявить 
мягкой ссылку D->A. Что тогда произойдет:
* A покидает область видимости, и, благодаря мягкости ссылки D->A счетчик ссылок 
на нее станет нулевым.
* память A может быть освобождена, для B мы получаем -1 в счете ссылок, он тоже 
может быть освобожден.
* для C ситуация повторяется как в случае с B.
* с D ситуация аналогичная. У нас есть ссылка на A, но, она мягкая, и 
дополнительных действий от нас не требует.
* вся занимаемая память может вернуться в систему.

Теперь можно вернуться к вопросам.

1. Чтобы память не текла, мы не должны позволять в ссылках циклов со всеми 
жесткими ссылками. В нашем коде, в переменной, которая хранит ссылку на 
конструкцию A->B->C->D->A будет хранится указание на объект A. Тоесть, 
как только переменная, пусть это будет $a, выйдет из области видимости, 
начнется процесс очистки памяти. Освободится A, потом B, C и D. Сейчас 
у нас вся память свободна, нам нужно просто позволить этому процессу 
закончится. Для этого нужно убедить сборщик мусора проигнорировать ссылку D->A. 
Сделав ее мягкой, мы добьемся желаемого.
2. Да, можно.
3. Особенности работы с мягкими ссылками проистекают из их природы. 
    1. Если на объект есть только мягкие ссылки, то его память может быть освобождена.
    2. Если вы храните мягкую ссылку на объект, проверяйте его существование перед 
    использованием, возможно, что его уже "собрали".
## Шестое задание
### Работа с памятью
```perl
while (1) {
    my $a = {};
    $a->{func} = sub {
        $a->{cnt}++;
    };
}
```
Что произойдет с памятью в этом примере и почему? Как исправить положение?
#### Решение
Хотя код и не выполняет ни какой работы, он все равно течет. 
Анонимная функция захватывает внешний контекст и не позволяет очистить память 
переменной $a. Лечится  $a->{func} = undef или weaken($a) в конце цикла.
## Седьмое задание
### HTTP запрос
Пожалуйста, при выполнении этого задания не пользуйтесь LWP::*, он не
поможет во втором пункте задания, да и задание это нужно, чтобы
посмотреть как вы умеете работать с сокетами, а не как это умеют
работать модули.

В качестве решения второй части задания мы также готовы засчитать
решение с помощью какого-либо модуля, однако вручную все же намного
лучше, т.к., повторюсь, в реальной жизни конечно можно и не писать
такие вещи в ручную, но знание этого и специфики асинхронной работы –
очень важно.
#### 7.1 Синхронный
Написать функцию http_get($host, $path, $query, $timeout), которая делает
http запрос на адрес http://$host/$path?$query с таймаутом $timeout.
Реализация http должна быть примитивной, то есть мы рассчитываем на
ответ HTTP 200 OK с content-length.
$query передают в функцию хешом.
#### 7.2 Асинхронный
А также написать асинхронную версию этой функции, которая (для
простоты задания) отличается тем, что пока ждет ответа занимается
заполнением какого-нибудь массива числами и выводит на экран
сколько элементов успела добавить пока ждала ответа удаленного
сервера. Программа должна оставаться в рамках 1 процесса и 1 потока
(т.е. без fork и без threads).
#### Решение
Синхронная и асинхронная версия получения страницы GET запросом 
представлены в модуле Task7.pm. Функции отправляют запрос на 
указанный адрес и выводят ответ. Асинхронная версия get_http_async, 
примерно раз в секунду, рисует точки пока ждет соединения и данные. 
Скрипт task7.pl позволяет испытать их в действии.
## Восьмое задание
### Наследование
Есть следующие классы:
```perl
package AA;
sub func { print “AA\n” }
package BB;
use parent ‘AA’;
sub func { print “BB\n”; shift->SUPER::func(@_); }
package CC;
use parent ‘AA’;
sub func { print “CC\n”; shift->SUPER::func(@_); }
package DD;
use parent qw/BB CC/;
sub func { print “DD\n”; shift->SUPER::func(@_); }
```
В каких классах и в каком порядке будут вызваны функции func, если
вызвать DD->func?
По какому принципу мы должны построить наследование, если нам
необходимо, чтобы при вызове DD->func, были вызваны функции во всех
этих классах, и не меняя иерархию наследования?
#### Решение
Класс DD имеет свою реализацию метода func, который вызывается по условию 
задачи. Значимым для нас является вызов shift->SUPER::func(@_).
Его наличие приводит к поиску реализации метода func в родительских 
классах. Первым будет просмотрен, в порядке оьъявления предков, класс BB. 
Этот класс имеет свою реализацию метода func, которая и будет вызвана. 
Вызов SUPER метода присутствует и там. Предком класса BB является класс AA.
Мы вызываем его метод func и на этом наши поиски заканчиваются. Ответ 
на первый вопрос: будут вызваны методы в классах DD->BB->AA, 
метод класса CC не будет вызван.

Второй вопрос, слегка, требует уточнения. Что для нас критично, 
порядок наследования, или, порядок вызова методов? Если нам нужно, чтобы 
метод в классах вызывался в порядке DD->BB->CC->AA, то добится этого можно 
такими путями:
* путь, ради которого, скорее всего, и задавался вопрос, немного поправим код:
```perl
package DD;
sub func {
    print "DD\n";
    shift->next::method(@_);
}
```
* иногда может быть преемлемо, хотя врядли является решением:
```perl
package AA;
sub func { print “AA\n” }
package CC;
use parent qw/AA/;
sub func { print “CC\n”; shift->SUPER::func(@_); }
package BB;
use parent qw/СС/;
sub func { print “BB\n”; shift->SUPER::func(@_); }
package DD;
use parent qw/BB/;
sub func { print “DD\n”; shift->SUPER::func(@_); }
```
## Девятое задание
### Поиск в массиве
Дан массив из большого числа элементов (числа), отсортированный по
возрастанию. Необходимо написать функцию, которая быстро найдет
индекс элемента массива, значение по которому наиболее близко к
переданному в аргументах функции числу.
Используйте модуль Benchmark, чтобы оценить скорость написанного
решения и оптимизировать его.
#### Решение
Если упорядоченность - единственное, что известно о массиве, то алгоритм 
"деления пополам" даст вполне хорошие результаты. В модуле Task9.pm 
реализован прямой перебор, метод "деления пополам", и деления 
в пропорции "золотого сечения".
## Общие вопросы
_Какие модули вы обычно используете в качестве Web Framework?_

Если выпадает шанс что - то сделать с нуля, то mojolicious. Про catalyst 
сейчас знаю чисто теоретически, практику давно и осознанно забросил, из за 
нехилого списка его зависимостей.

_Для работы с базой, датами? А какие модули используете в принципе всегда или часто?_

Так сложилось, что основное направление моей работы - это поддержка и 
развитие существующих проектов. Я стараюсь не изобретать велосипедов, когда 
метаспан или гугл могут предложить готовые решения, и всегда отталкиваюсь от 
того, что уже есть в проекте. С базой связываюсь, в основном, через DBI. 
С датами - DateTime. В общем и целом, придерживаюсь принципа минимальных 
изменений окружения, если без этого можно обойтись, не делая код сложнее.
## Игровой чат
Необходимо реализовать чат в игре, при этом все механизмы надо
написать самостоятельно. Какие это механизмы и как структурно это
будет выглядеть?
#### Решение
Не уверен, что правильно понял вопрос, поэтому постараюсь ответить максимально полно.

Протокол взаимодействия клиента и сервера - конечно websocket. 
В браузерах присутствует, пожалуй, везде. Достаточно гибок. Накоплен достаточный 
опыт использования, чтобы понимать его возможности. Пример возможной реализации 
online общения находится в скрипте chat.pl. Фреймворк mojolicious. 
Минимум разметки и js. Почти все утащено из документации.

В общем случае, чат может не только являтся вспомогательным сервисом, но 
и стать основой для полноценной реализацией игр вроде карточных, шахмат, шашек 
и многих других, где не идет речи о динамичной графике.

Для реализации подобного сервиса видится следующая последовательность шагов: 
* Реализация игрового мира. В терминах чат системы, основная комната, доступная 
всем - это мир игры. Сюда попадают все зашедшие на сервер игроки. 
Комнаты - это может быть просто помещение, где присутствующе видят только друг друга, 
игровая локация, со своим сценарием, или конкретная игра, например, партия в дурочка, 
если помнить о картах. Локация может давать свои возможности, например, 
обратиться к крупье, или маскировать возможности игрока, временно отключая 
некоторые. Например, нельзя входить в две игры сразу, да и сидеть в 2 комнатах 
за раз - тоже странно, с точки зрения здравого смысла.
* Реализация участников процесса. Речь не только об игроках, но и 
администраторах, которые следят за порядком, крупье, если речь о картах, 
возможно, еще каких то персонажах, исходя из потребностей и сценария. 
что наверняка потребуется:
    * Работать с постоянными данными игрока. Учетные данные, профиль, настройки. Все 
    это нужно уметь создавать, обновлять, читать и предоставлять по запросам в 
    соответствии с привелегиями спрашивающего. Эти api будут наиболее общими, потому 
    как требуются почти для любого типа участников.
    * Любому участнику доступны какие - то игровые действия. Авторизоваться и выходить 
    из игры, перемещатся по комнатам, вступать в игры, писать в общий и приватный чаты. 
    Эти возможности собираются в api конкретных объектов.
* Реализация игрового протокола. В данном случае имеется ввиду не только и не столько 
коммуникации, сколько трансляция команд в действия с текущим контекстом игрока, места и 
игрового сценария.
* Реализация управляющей логики игры. Запрос на авторизацию и вход в игру видится разумным 
поручить этому api. После авторизации загружаем данные игрока из профиля, фомируем его 
контекст, считаем харрактеристики, с поправкой на инвентори и свойства текущей локации, 
если предусмотренно сценарием. Помещение игрока в коллекцию onlain участников и в дело 
вступает основной цикл игры.
* Основной цикл работы игры мог бы быть таким: мы наблюдаем за игроками onlain, когда 
произойдет какая-то активность с их стороны, для каждого из них, мы транслируем запрос в 
вызовы api игрока и локации, которые, в конечном итоге, обновят его контекст. Когда это 
произойдет, мы фиксируем изменения в чем - то, способном пережить перезагрузку, если она 
случится, сообщаем на клиента его новые данные.
* Отдельный цикл будет следить за протяженными во времени изменениями. Это может быть 
восстановление здоровья или длительность бана от администратора, 
смотря что предусматривает сценарий.

На вскидку в голову пришли такие соображения.
## Раздача карт
Есть стандартная колода из 52 карт. Надо перемешать и раздать на 9
человек по 2 карты и положить 5 карт отдельно. Приведите код, который
выполнит данные действия.
#### Решение
Модуль DealingCards.pm реализует требуемый функционал. 
Функция dealing_cards тасует колоду и 
сдает карты на 9 игроков (индексы в хэше 1..9), 
отдельно 5 карт (индекс five), и отстаток колоды 
(индекс deck), возвращая все данные в виде ссылки на хэш. 
Функция card_info вернет ссылку на массив где будут цвет, масть, 
достоинство и индекс, по которому все вычислялось. Скрипт dealing.pl 
позволит убедится в работоспособности реализации.